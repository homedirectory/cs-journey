#lang sicp

(#%require "../../helpers.scm")

; ----- Streams -----

(define (memo-proc proc)
  (let ((already-run? false) (result false))
    (lambda ()
      (if (not already-run?)
          (begin (set! result (proc))
                 (set! already-run? true)
                 result)
          result))))

(define the-empty-stream '())
(define stream-null? null?)


; Thank you, ivanjovanovic.
; So this is called a macro and we have to use it here instead of a regular
; procedure definition so that the argument `b` does not get evaluated
; before being passed to the delay function. This is an essential requirement
; for streams.
; This is how I understand macros:
; whenever `cons-stream` is encountered by the interpreter it asks the
; macro-expander to transform `cons-stream a b` into `(cons a (delay b))` or
; whatever it might be that you defined according to the rules you defined.
; Here I defined `cons-stream` to be interpreted as a procedure that takes
; 2 arguments.
(define-syntax cons-stream
  (syntax-rules ()
    ((cons-stream a b)
     (cons a (delay b)))
    )
  )

(define (stream-car stream) (car stream))
(define (stream-cdr stream) (force (cdr stream)))

(define (stream-ref s n)
  (if (= n 0)
      (stream-car s)
      (stream-ref (stream-cdr s) (- n 1))))

(define (stream-map proc . argstreams)
  (if (stream-null? (car argstreams))
      the-empty-stream
      (cons-stream
       (apply proc (map (lambda (s) (stream-car s)) argstreams))
       (apply stream-map (cons proc
                               (map (lambda (s) (stream-cdr s))
                                    argstreams)))
       )
      )
  )

(define (stream-for-each proc s)
  (if (stream-null? s)
      'done
      (begin (proc (stream-car s))
             (stream-for-each proc (stream-cdr s)))))

(define (stream-filter pred stream)
  (cond ((stream-null? stream) the-empty-stream)
        ((pred (stream-car stream))
         (cons-stream (stream-car stream)
                      (stream-filter
                       pred
                       (stream-cdr stream))))
        (else (stream-filter pred (stream-cdr stream)))))

(define (display-stream s)
  (stream-for-each display-line s))
(define (display-line x) (newline) (display x))

(define (stream-enumerate-interval low high)
  (if (> low high)
      the-empty-stream
      (cons-stream
       low
       (stream-enumerate-interval (+ low 1) high))
      )
  )

; prints fist n elements of the stream
(define (print-stream stream n)
  (define (f s c)
    (if (and (< c n) (not (stream-null? s)))
        (begin
          (display (stream-car s))
          (display ", ")
          (f (stream-cdr s) (inc c))
          )
        )
    )

  (display "(")
  (f stream 0)
  (display ")")
  (newline)
  )


(define (mul-streams . argstreams)
  (apply stream-map (cons * argstreams))
  )


(define (merge s1 s2)
  ;  (newline)
  ;  (print "merge " s1 " " s2)
  (cond ((stream-null? s1) s2)
        ((stream-null? s2) s1)
        (else
         (let ((s1car (stream-car s1))
               (s2car (stream-car s2)))
           (cond ((< s1car s2car)
                  (cons-stream
                   s1car
                   (merge (stream-cdr s1) s2)))
                 ((> s1car s2car)
                  (cons-stream
                   s2car
                   (merge s1 (stream-cdr s2))))
                 (else
                  (cons-stream
                   s1car
                   (merge (stream-cdr s1)
                          (stream-cdr s2)))))))))


(define (stream-neg stream)
  (stream-map (lambda (x) (- x)) stream)
  )

; -- Infinite Streams --
(define (integers-starting-from n)
  (cons-stream n (integers-starting-from (+ n 1)))
  )

(define integers (integers-starting-from 1))

(define (divisible? x y) (= (remainder x y) 0))

; the sieve of Eratosthenes for computing prime numbers
(define (sieve stream)
  (cons-stream
   (stream-car stream)
   (sieve (stream-filter
           (lambda (x)
             (not (divisible? x (stream-car stream))))
           (stream-cdr stream)))
   )
  )

(define primes (sieve (integers-starting-from 2)))


; * Defining streams implicitly *
(define ones (cons-stream 1 ones))

(define (add-streams . argstreams)
  (apply stream-map (cons + argstreams))
  )

(define integers-impl (cons-stream 1 (add-streams ones integers)))


; This definition says that fibs is a stream beginning with 0 and 1, such
; that the rest of the stream can be generated by adding fibs to itself
; shifted by one place:
(define fibs
  (cons-stream
   0
   (cons-stream 1 (add-streams (stream-cdr fibs) fibs))
   )
  )


; Multiply each element in a stream by a constant
(define (scale-stream stream factor)
  (stream-map (lambda (x) (* x factor))
              stream)
  )


(define primes-impl
  (cons-stream
   2
   (stream-filter prime? (integers-starting-from 3))
   )
  )

(define (prime? n)
  (define (iter ps)
    (cond ((> (square (stream-car ps)) n) true)
          ((divisible? n (stream-car ps)) false)
          (else (iter (stream-cdr ps)))
          )
    )
  
  (iter primes-impl)
  )


(define (partial-sums stream)
  (define s (cons-stream
             (stream-car stream)
             (add-streams s (stream-cdr stream))
             )
    )
  s
  )


; get first n elements as list
(define (stream->list stream n)
  (define (f s lst c)
    (if (= c n)
        lst
        (f (stream-cdr s)
           (append lst (list (stream-car s)))
           (inc c))
        )
    )

  (f stream (list) 0)
  )

(define (list->stream lst)
  (if (null? lst)
      the-empty-stream
      (cons-stream (car lst) (list->stream (cdr lst)))
      )
  )


(define (stream-from-proc proc)
    (cons-stream (proc) (stream-from-proc proc))
  )

;-------------------------------------------------
(#%provide the-empty-stream stream-null? cons-stream stream-car stream-cdr
           stream-ref stream-map stream-filter stream-for-each
           stream-enumerate-interval display-stream print-stream
           merge mul-streams stream-neg add-streams scale-stream integers
           partial-sums stream->list list->stream stream-from-proc)
